/**
 * Roll Delegation - Deterministic peer selection for fair dice rolls
 *
 * To prevent cheating, dice rolls are generated by a random peer rather than
 * the player who initiates the roll. This module provides deterministic peer
 * selection so all peers agree on who should generate a given roll.
 */

/**
 * Simple string hash function (djb2 algorithm)
 * @param {string} str - String to hash
 * @returns {number} - Positive 32-bit integer hash
 */
export function hashString(str) {
  let hash = 5381;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) + hash) + str.charCodeAt(i);
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash);
}

/**
 * Select which peer should generate the roll values
 *
 * Uses deterministic selection so all peers agree without coordination:
 * 1. Filter out the requester (you shouldn't roll your own dice)
 * 2. Sort eligible peers for consistent ordering
 * 3. Use hash of rollId to select from eligible peers
 *
 * @param {string[]} allPeerIds - Array of all connected peer IDs (including self)
 * @param {string} requesterId - ID of the peer requesting the roll
 * @param {string} rollId - Unique identifier for this roll request
 * @returns {{ generatorId: string, isSelfRoll: boolean }} - Selected generator and whether it's a self-roll
 */
export function selectRollGenerator(allPeerIds, requesterId, rollId) {
  // Filter out the requester - they shouldn't roll their own dice
  const eligiblePeers = allPeerIds.filter(id => id !== requesterId);

  // Solo player - must self-roll
  if (eligiblePeers.length === 0) {
    return {
      generatorId: requesterId,
      isSelfRoll: true
    };
  }

  // Sort for deterministic ordering across all peers
  const sortedPeers = [...eligiblePeers].sort();

  // Use hash to select peer
  const hash = hashString(rollId);
  const index = hash % sortedPeers.length;

  return {
    generatorId: sortedPeers[index],
    isSelfRoll: false
  };
}

/**
 * Select the next peer to try after a timeout
 *
 * @param {string[]} allPeerIds - Array of all connected peer IDs
 * @param {string} requesterId - ID of the peer requesting the roll
 * @param {string} rollId - Unique identifier for this roll request
 * @param {string[]} failedPeerIds - Peers that have already timed out
 * @returns {{ generatorId: string, isSelfRoll: boolean } | null} - Next peer to try, or null if exhausted
 */
export function selectNextGenerator(allPeerIds, requesterId, rollId, failedPeerIds) {
  // Filter out requester and failed peers
  const eligiblePeers = allPeerIds.filter(
    id => id !== requesterId && !failedPeerIds.includes(id)
  );

  // No more peers to try
  if (eligiblePeers.length === 0) {
    return null;
  }

  // Sort and select next
  const sortedPeers = [...eligiblePeers].sort();
  const hash = hashString(rollId);
  const index = hash % sortedPeers.length;

  return {
    generatorId: sortedPeers[index],
    isSelfRoll: false
  };
}

/**
 * Generate dice values for a roll request
 *
 * @param {Array<{setId: string, count: number}>} diceSets - Dice sets to roll
 * @param {Array<{setId: string, lockedIndices: number[], values: number[]}>} lockedDice - Locked dice info
 * @returns {Object<string, number[]>} - Roll results by set ID
 */
export function generateDiceValues(diceSets, lockedDice = []) {
  const results = {};

  for (const set of diceSets) {
    const lockedInfo = lockedDice.find(l => l.setId === set.setId);
    const lockedMap = new Map();

    if (lockedInfo) {
      for (let i = 0; i < lockedInfo.lockedIndices.length; i++) {
        lockedMap.set(lockedInfo.lockedIndices[i], lockedInfo.values[i]);
      }
    }

    // Generate values, preserving locked dice
    const values = Array(set.count).fill(0).map((_, i) => {
      if (lockedMap.has(i)) {
        return lockedMap.get(i); // Keep locked value
      }
      return Math.floor(Math.random() * 6) + 1; // Roll new value
    });

    results[set.setId] = values;
  }

  return results;
}

/**
 * Validate that roll values are within acceptable range
 *
 * @param {Object<string, number[]>} rollResults - Roll results by set ID
 * @returns {boolean} - True if all values are valid (1-6)
 */
export function validateRollValues(rollResults) {
  for (const setId in rollResults) {
    const values = rollResults[setId];
    if (!Array.isArray(values)) return false;

    for (const v of values) {
      if (!Number.isInteger(v) || v < 1 || v > 6) {
        return false;
      }
    }
  }
  return true;
}

// Constants
export const ROLL_TIMEOUT_MS = 3000;  // Time to wait for designated peer
export const MAX_RETRIES = 2;          // Maximum retry attempts before self-roll
